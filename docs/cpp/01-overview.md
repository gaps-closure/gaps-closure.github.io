# [TODO: MIKE] CLOSURE Toolchain Overview {#toolchain-overview}

## What is CLOSURE? 

DARPA's Guaranteed Architecture for Physical Systems (GAPS) is a research program 
that addresses software and hardware for compartmentalized applications where
multiple parties with strong physical isolation of their computational
environment, have specific constraints on data sharing (possibly with redaction
requirements) with other parties, and any data exchange between the parties is
mediated through a guard that enforces the security requirements.

Peraton Labs' Cross-domain Language extensions for Optimal SecUre Refactoring
and Execution (CLOSURE) project is building a toolchain to support the
development, refactoring, and correct-by-construction partitioning of
applications and configuration of the guards. Using the CLOSURE approach and
toolchain, developers will express security intent through annotations applied
to the program, which drive the program analysis, partitioning, and code
autogeneration required by a GAPS application.

**Problem:** The machinery required to verifiable and securely establish
communication between cross-domain systems (CDS) without jeopardizing data
spillage is too complex to implement for many software platforms where such
communication would otherwise be desired. To regulate data exchanges between
domains, network architects rely on several risk mitigation strategies
including human fusion of data, diodes, and hypervisors which are insufficient
for future commercial and government needs as they are high overhead,
customized to specific setups, prone to misconfiguration, and vulnerable to
software/hardware security flaws. To streamline the design, development, and
deployment of provably secure CDSs, new hardware and software co-design tools
are needed to more effectively build cross-domain support directly into
applications and associated hardware early in the development lifecycle.

**Solution:** Peraton Labs is developing CLOSURE (Cross-domain
Language-extensions for Optimal SecUre Refactoring and Execution) to address
the challenges associated with building cross-domain applications in software.
CLOSURE extends existing programming languages by enabling developers the
ability to express security intent through overlay annotations and security
policies such that an application can be compiled to separable binaries for
concurrent execution on physically isolated platforms.

The CLOSURE compiler toolchain interprets annotation directives and performs
program analysis of the annotated program and produces a correct-by-construction 
partition if feasible. CLOSURE automatically generates and inserts serialization, marshaling, and remote-procedure call code for cross-domain interactions
between the program partitions.

## The C++ Challenge
As stated in @solodkyythesis, "writing a tool capable of assuring a property that falls out of the scope of the standard type checking performed by a compiler is a task comparable to writing the compiler itself." This is especially true with respect to C++ where an extensive list of object-oriented features makes it difficult to conduct the required program analysis to track the control and data dependencies incurred by multiple inheritance, polymorphism, templates, exceptions, overrides, etc. Unlike C and Java for which extensive research and tools for formal dependency modeling exists @ptrsplit @joana, the set of such tools for C++ are sparse. While a large subset of the C language has been formalized @Blazy @depthsofc, formalisms for analysis of C++ programs @solodkyythesis @Batty2015TheCA handle a limited subset of the C++ language.  For example, cpp2v @brick does not support templates, virtual inheritance, floating point numbers, and many other critical features. Other approaches to formalize C++ for analysis exhibit other limitations that fall short of their applicability to real-world C++ programs. The alternative approach of defining type extensions and rewriting the program based on those extensions so that the type checker can check for properties is not pragmatic due to the learning curve, lack of tooling support for non-standard extensions, and cost of rewriting legacy programs in the new dialect. Much of the CLOSURE analyses occur at the LLVM-IR level, and that generated by C++ is far more difficult to understand without proper tools (names are mangled, classes and objects are refactored, etc.). Further complicating the effort is the lack of reflection in C++ (afforded to us in Java) for explicitly describing the types of fields and structure of opaque objects as they are marshalled and serialized for streaming communications across guard devices.  

In the final six months of GAPS Phase 3, we turned our focus to that of a preliminary CLOSURE C++ toolchain proof-of-concept design. In the following sections, we document our findings, initial approach, and early implementation. Our proof-of-concept toolchain builds around the C++20 compiler, though we stick to programs of C++98 complexity, incrementally adding support for modern features as they become of interest. Several of the toolchain steps are conducted manually with plans to automate them in future research.

Our approach follows the same high-level workflow that has proven successful for us in C and Java:

- Leverage our LLVM-Based approaches
- Build a program model representation that comprises the AST, control flow graph, data flow graph, and points-to analysis
- Extend application of CLOSURE Language Extensions (CLE) to Object Oriented constructs (building upon our work for a subset of Java) to cover a subset of C++ adequate to meet the transition partner code
- Extend the formal constraint model for C++ constructs
- Code generation to manage cross-domain object instantiation, destruction, and methods


## Architecture 

XXX: the figure may be better for workflow

The CLOSURE architecture for C++ is shown in [the figure below](#fig-arch).
The architecture follows the same workflow that has proven successful for C and Java with language-specific differences in annotation, modeling, constraint, and code-generation steps which is expected.  

![CLOSURE architecture](docs/cpp/images/arch.png){#fig-arch}


Some key differences between the C++ proof-of-concept toolchain and its C/Java counterparts include:

(i) annotations of fields, methods (including constructors/destructors), and class definitions in addition to functions and data; (ii) leveraging of the Clang AST to facilitate annotation and program analysis; (iii) program modeling derived from the SVF Graph (SVFG) which replaces the PDG; (iv) object-oriented constraints; and (v) RPC/Serialization code conducive to C++ semantics. See \ref{fig-workflow}.

## Workflow 

![CLOSURE Workflow](docs/cpp/images/workflow.png){#fig-workflow}

XXX: Discussion of a manual end-to-end should go here, roughly based on Ta's processing of cpp/example 2. We should create a workflow diagram to go here and show where manual/automated actions occur; which intermediate/final artifacts are created. 

## Document Roadmap 

XXX: Revise once the document is complete

In the rest of this document, we first present a quick start guide followed by a detailed usage of 
the toolchain components. For each component, we describe what it does, provide some insight into
how it works, discuss inputs and outputs and provide invocation syntax for usage. We conclude with 
a discussion of the limitations of our current toolchain and a roadmap for future work. We provide 
samples of significant input and output files in the appendices and provide a list of bibliographic 
references at the end. 
