@misc{minizinc_handbook, 
  title={The minizinc handbook}, 
  url={https://www.minizinc.org/doc-2.5.5/en/index.html}, 
  journal={The MiniZinc Handbook - The MiniZinc Handbook 2.5.5}, 
  author={Stuckey, Peter J. and Marriott, Kim and Tack, Guido}, 
  year={2022}
} 

@article{Docker,
  title={Docker: lightweight linux containers for consistent development and deployment},
  author={Merkel, Dirk},
  journal={Linux journal},
  volume={2014},
  number={239},
  pages={2},
  year={2014}
} 

@misc{VSCode, 
  year={2022}, 
  title={Visual Studio Code}, 
  url={https://code.visualstudio.com/}, 
  journal={Visual Studio Code -  Code editing. Redefined.}, 
  publisher={Microsoft}
} 

@misc{DFDL, 
  year={2022}, 
  title={Data Format Description Language (DFDL) v1.0 Specification}, 
  url={https://daffodil.apache.org/docs/dfdl/}, 
  journal={Data Format Description Language (DFDL) v1.0 Specification}, 
  publisher={The Apache Software Foundation}, 
  author={Beckerle, Michael  J and Hanson, Stephen M}
} 

@inproceedings{joana,
  title = {Using JOANA for Information Flow Control in Java Programs - A Practical Guide},
  booktitle = {Proceedings of the 6th Working Conference on Programming Languages (ATPS'13)},
  year = {2013},
  month = feb,
  publisher = {Springer Berlin / Heidelberg},
  pages = {123--138},
  author = {J{\"u}rgen Graf and Martin Hecker and Martin Mohr},
  series = {Lecture Notes in Informatics (LNI) 215},
}

@misc{CDoc, 
  year={2022}, 
  title={CLOSURE Toolchain User Manual for CLanguage}, 
  url={https://github.com/gaps-closure/gaps-closure.github.io/tree/develop/docs/C}, 
  publisher={GitHub}
}

@inproceedings{aop-inproceedings,
  author = {Kiczales, Gregor and Lamping, John and Mendhekar, Anurag and Maeda, Chris and Lopes, Cristina and Loingtier, Jean-Marc and Irwin, John},
  year = {1997},
  month = {06},
  pages = {220-242},
  title = {Aspect-Oriented Programming},
  volume = {1241},
  isbn = {9783540630890},
  journal = {European Conference on Object-Oriented Programming},
  doi = {10.1007/BFb0053381}
}

@phdthesis{cernythesis,
  author = {Černý, Tom},
  year = {2016},
  month = {01},
  pages = {},
  title = {On Concern-separation of Data Presentations in User Interfaces}
}

@misc{aspectj-env, 
  year={2005}, 
  title={The AspectJ Development Environment Guide}, 
  url={https://www.eclipse.org/aspectj/doc/next/devguide/printable.html}, 
  publisher={Xerox}
} 

@misc{aspectj-prog, 
  year={2003}, 
  title={The AspectJ Programming Guide}, 
  url={https://www.eclipse.org/aspectj/doc/next/progguide/index.html}, 
  publisher={Xerox}
} 

@phdthesis{solodkyythesis,
  author = {Solodkyy, Y.},
  year = {2013},
  title = {Simplifying The Analysis of C++ Programs},
  month = {},
  pages = {}
}

@inproceedings{ptrsplit,
  author = {Liu, Shen and Tan, Gang and Jaeger, Trent},
  title = {PtrSplit: Supporting General Pointers in Automatic Program Partitioning},
  year = {2017},
  isbn = {9781450349468},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3133956.3134066},
  doi = {10.1145/3133956.3134066},
  abstract = {Partitioning a security-sensitive application into least-privileged components and putting each into a separate protection domain have long been a goal of security practitioners and researchers. However, a stumbling block to automatically partitioning C/C++ applications is the presence of pointers in these applications. Pointers make calculating data dependence, a key step in program partitioning, difficult and hard to scale; furthermore, C/C++ pointers do not carry bounds information, making it impossible to automatically marshall and unmarshall pointer data when they are sent across the boundary of partitions. In this paper, we propose a set of techniques for supporting general pointers in automatic program partitioning. Our system, called PtrSplit, constructs a Program Dependence Graph (PDG) for tracking data and control dependencies in the input program and employs a parameter-tree approach for representing data of pointer types; this approach is modular and avoids global pointer analysis. Furthermore, it performs selective pointer bounds tracking to enable automatic marshalling/unmarshalling of pointer data, even when there is circularity and arbitrary aliasing. As a result, PtrSplit can automatically generate executable partitions for C applications that contain arbitrary pointers.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages = {2359–2371},
  keywords = {data marshalling, automatic program partitioning, bounds tracking},
  location = {Dallas, Texas, USA},
  series = {CCS '17}
}

@article{Blazy,
  title={Mechanized Semantics for the Clight Subset of the C Language},
  volume={43},
  ISSN={1573-0670},
  url={http://dx.doi.org/10.1007/s10817-009-9148-3},
  DOI={10.1007/s10817-009-9148-3},
  number={3},
  journal={Journal of Automated Reasoning},
  publisher={Springer Science and Business Media LLC},
  author={Blazy, Sandrine and Leroy, Xavier},
  year={2009},
  month=jul, pages={263–288} 
}

@inproceedings{depthsofc,
  author = {Memarian, Kayvan and Matthiesen, Justus and Lingard, James and Nienhuis, Kyndylan and Chisnall, David and Watson, Robert N. M. and Sewell, Peter},
  title = {Into the Depths of C: Elaborating the de Facto Standards},
  year = {2016},
  isbn = {9781450342612},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2908080.2908081},
  doi = {10.1145/2908080.2908081},
  abstract = {C remains central to our computing infrastructure. It is notionally defined by ISO standards, but in reality the properties of C assumed by systems code and those implemented by compilers have diverged, both from the ISO standards and from each other, and none of these are clearly understood. We make two contributions to help improve this error-prone situation. First, we describe an in-depth analysis of the design space for the semantics of pointers and memory in C as it is used in practice. We articulate many specific questions, build a suite of semantic test cases, gather experimental data from multiple implementations, and survey what C experts believe about the de facto standards. We identify questions where there is a consensus (either following ISO or differing) and where there are conflicts. We apply all this to an experimental C implemented above capability hardware. Second, we describe a formal model, Cerberus, for large parts of C. Cerberus is parameterised on its memory model; it is linkable either with a candidate de facto memory object model, under construction, or with an operational C11 concurrency model; it is defined by elaboration to a much simpler Core language for accessibility, and it is executable as a test oracle on small examples. This should provide a solid basis for discussion of what mainstream C is now: what programmers and analysis tools can assume and what compilers aim to implement. Ultimately we hope it will be a step towards clear, consistent, and accepted semantics for the various use-cases of C.},
  booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages = {1–15},
  numpages = {15},
  keywords = {C},
  location = {Santa Barbara, CA, USA},
  series = {PLDI '16}
}

@inproceedings{Batty2015TheCA,
  title={The C11 and C++11 concurrency model},
  author={Mark Batty},
  year={2015},
  url={https://api.semanticscholar.org/CorpusID:84182258}
}

@misc{brick, 
  year={}, 
  title={BRiCk}, 
  url={https://github.com/bedrocksystems/BRiCk}, 
  publisher={Github}
} 
