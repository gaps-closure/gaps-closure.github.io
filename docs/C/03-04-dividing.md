## Code Dividing and -Refactoring


Once the CAPO partitioning conflict analyzer has analyzed the CLE-annotated application code, and determined that all remaining conflicts are resolvable by RPC-wrapping to result in a security compliant cross-domain partitioned  code, the conflict analyzer will save the code in the refactored directory along with a a topology file (JSON) containing the assignment of every  function and global variable to an enclave/level. A sample topology JSON is provided below.

```
{
   "levels": ["orange", "purple"],
   "source_path": ["./refactored"],
   "functions": [
      {"name": "get_a", "level": "orange", "file": "test1_refactored.c", "line": 29},
      {"name": "main",  "level": "purple", "file": "test1_refactored.c", "line": 35},
      ...
    ],
   "global_scoped_vars": [
      {"name": "globalScopeVarNotFunctionStatic", "level": "purple", "file": "test1_refactored.c", "line": 5},
      ...
    ],
}
```

Given the refactored, annotated application, and the topology, the divider creates a `divvied` directory, divides the code into files in separate subdirectories (one per enclave), such that the source code for each function or global variable is placed in its respective enclave. Furthermore, all related code like type, variable, and function declarations, macro definitions, header includes, and pragmas are handled, so that the source in each directory has all the relevant code, ready for automated partitioning and code generation for RPC-wrapping of functions, and marshalling, tagging, serialization, and DFDL description of cross-domain data types.

This `divvied` source becomes the input to the GAPS Enclave Definition Language (GEDL) generator tool. The GEDL drives further code generation and modification needed to build the application binaries for each enclave.

### dividing

**Whoever wrote the divider should document this section**

### opt pass for GEDL and configuring heuristics

GEDL will be produced in JSON format as a file named "Enclaves.gedl"
An example GEDL file would look like:
{"gedl": [
	{
		"caller": "enclave1",
		"callee": "enclave2",
		"calls": [
			{
				"func":		"sampleFunc",
				"return":	{"type": "double"},
				"clelabel":	"enclave1",
				"params": [
					{"type": "int", "name": "sampleInt", "dir": "in"}, 
					{"type": "double", "name": "sampleDoubleArray", "dir": "inout", "sz":15} 
				],
				"occurs": [
					{"file": "/sample/Enclave1/Path/Enclave1File.c", "lines": [44]},
                                        {"file": "/sample/Enclave1/Path/Enclave1File2.c", "lines": [15,205]}

				]
			},
        {
				"func":		"sampleFunc2",
				"return":	{"type": "int"},
				"clelabel":	enclave1Extra,
				"params": [
				],
				"occurs": [
					{"file": "/sample/Enclave1/Path/Enclave1File.c", "lines": 45}
				]
			}
		]
	},
        {
		"caller": "enclave2",
		"callee": "enclave3",
		"calls": [
			{
				"func":		"sampleFunc3",
				"return":	{"type": "void"},
				"clelabel":	enclave2,
				"params": [
					{"type": "uint8", "name": "sampleUInt8", "dir": "in"} 
				],
				"occurs": [
                    {"file": "/sample/Enclave1/Path/Enclave2File.c", "lines": [55,87]}
				]
			}
		]
	}
]}

**TODO: put following in appendix** 
Key Table:
gedl:   
        The top level key, contains one object for each unique ordered
        pair of enclaves with cross-domain calls. This is determined by
        checking which importedFunctions from an imported_func.txt file
        are also present in a defined_func.txt of a different enclave.
        These files are generated by compiling the contents of the indicated
        directories into .ll files with names matching the directories, then
        running opt with -llvm-test and -prefix flags on each file.

        Represented by a JSON array of objects of arbitrary size.
    caller: 
            The name of the enclave making the cross-domain call. 
            This will match the name of the directory containing the
            imported_func.txt file for the considered importedFunction.

            Represented by a double quote (") enclosed string that conforms
            to linux filename restrictions and in all lowercase.
    callee:
            The name of the enclave where the cross-domain call is 
            defined. This will match the name of the directory containing
            the defined_func.txt file for the considered importedFuncion.
    
            Represented by a double quote (") enclosed string that conforms
            to linux filename restrictions and in all lowercase.
    calls:  
            An array containing one object for each cross-domain function 
            called from "caller" and defined in "callee". This is determined
            by creating an entry for each unique function in the "caller" 
            imported_func.txt file that is present in "callee" defined_func.txt

            Represented by a JSON array of objects of arbitrary size.
    func:
            The function name of the cross-domain call. Determined by name in
            imported_func.txt.

            Represented by a double quote (") enclosed string conforming to
            c/c++ function name restrictions.
    return:
            An object defining the type of the function's return. 

            Represented by a JSON object with a single key type
        type:   
                A variable type representing the type of the function's return
                value. Determined by querying DIUtils.getDITypeName(), which 
                uses debug information to check the return type of the function. 

                Represented by a double quote (") enclosed string that is one of
                IDL's supported C types [double, ffloat, int8, uint8, int16, uint16,
                int32, uint32, int64, uint64] and not a pointer (no *)
    clelabel:  
            String value denoting the CLE labels that are tainting the function. This
            is determined by checking the CLE labels present in the LLVM IR in the function
            definition.

            Represented as a string value, with plaintext labels separated by commas.
    params: 
            Array containing one object for each argument passed to the function.
            Determined by querying PDGUtils for the list of arguments for the 
            current function name.

            Represented as a JSON array of objects, each with keys type, name, dir,
            and optionally sz.
        type:
                A variable type representing the type of a function's argument.
                Determined by querying DIUtils.getArgTypeName(), which uses
                debug information to check the argument type of the function. 

                Represented by a double quote (") enclosed string that is one of
                IDL's supported C types [double, ffloat, int8, uint8, int16, uint16,
                int32, uint32, int64, uint64] and not a pointer (no *).
        name:
                The argument name of the current argument. Determined by calling
                DIUtils.getArgName() which uses debug information to retrieve 
                argument name.

                Represented by a double quote (") enclosed string conforming to
                c/c++ argument name restrictions.
        dir:
                A string determining if read from or written to by the function
                to decide if it needs to be copied in/out.  Determined by using 
                arg.getAttribute() and checking if in, out, or both are attributes 
                for arg.

                Represented by a double quote (") enclosed string that is one of three values 
                "in", "out", "inout".
        sz:
                A number or word detailing the size of an array argument. Determined by 
                using arg.getAttribute() and checking if count, size, string, or user_check
                are attributes for arg.

                Represented by an unsigned integer or a string that is 
                either [string] or [user_check].
    occurs:
            Array containing one object for each callsite of function in "caller".
            Determined by checking callsiteMap, a Map object created at beginning of 
            AccessInfoTracker.cpp that maps every imported function to a Set of the files
            in the "caller" enclave where it is called. This is done by a module pass that
            examines the instructions of every function.

            Represented as a JSON array of objects, each with keys file and line.
        file:
                The path to a file in "caller" enclave containing calls to function.
                Determined by checking value of the current iterator on the Set 
                returned by callsiteMap.

                Represented by a double quote (") enclosed string that conforms to 
                linux path restrictions and refers to a valid c/c++ file on the system.
        lines:
                The line numbers of lines where calls to the function are made in the 
                current file. Determined by querying callsiteLines Map object created
                in the same manner as callsiteMap but recording lines.

                Represented by an array of unsigned integers which must not exceed the
                line count of the current file.


Input:
    A number of directories containing the *.c/h files for each enclave,
    These must be defined in the "enclaves" variable at the top of the Makefile.

Criteria:

    *No functions may have a pointer return type. Any functions with pointer returns must be refactored
        to instead return void and pass a new argument by reference that will act as the return
    *No duplicate functions across domains, except for multithreaded programs where "main" can be duplicated
    *Variables should not have any implicit casting to allow for automatic direction and size detection
    *Arguments and return types must be be of IDL supported types {"double","ffloat","int8","uint8","int16","uint16","int32","uint32","int64","uint64"} 

Warnings List:
        Warning and terminating error if return type is a pointer or unsupported
        Warning if direction for an argument is undetermined 
        Warning if size of an argument is undetermined
        Warning and if argument or type is not supported by IDL 
 TODO: (check if there is a method to allow function to be defined on both sides)       Warning and terminating error if function is defined in more than one domain (potentially more expensive than its worth)
        Warning if cross domain function does not have CLE label