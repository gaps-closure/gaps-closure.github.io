## Hardware Abstraction Layer (HAL) {#hal}

Partitioned application programs use HAL to communicate data through the GAPS devices, which we call Cross-Domain Guards (CDGs). HAL provides: a) data-plane routing, b) invokation of CLOSURE autogenerated codecs to handle data serialization and de-serialization, and c) formats data based on the requirements of each CDG. This section describes the two current HAL implementations and their associated configuration information.
- The [*HAL-Daemon*](#hal-daemon-implementation): a highly flexible middleware implementation that communicates with application using 0MQ.
- The *HAL-Library*: a simpler, more efficient library implementation directly linked to partitioned applications. 

First, however, we describe how HAL interfaces to the [Applications](#hal-xdcomms-api) and [CDGs](#hal-supported-cdgs), which are common to both implementations.


### HAL XDCOMMS API

Partitioned application programs use the same HAL cross-domain communication (XDCOMMS) API to communicate data, independent of the particular CDGs or HAL implementation. The HAL API simplifies cross-domain design by abstracting CDG details from the software application developer and the rest of the CLOSURE toolchain. In particular, HAL abstracts the details of particular CDG networking and formatting requirements. This section describes the abstract HAL data-plane API. 

Applications interact with the HAL through function calls defined in the HAL API library. The XDCOMMS API code is auto-generated as part of the *RPC generator* portion of the CLOSURE Automagic build step; thus the API is primarily of interest to cross-domain CLOSURE tool development. HAL can, however, be directly used by application developers to provide an abstract API to supported CDGs. 

#### HAL Data Plane Send and Receive API {#hal-data-plane-send-and-receive-api}

Applications can send and receive data by simply passing pointers to in-memory Application Data Unit (ADU) structures.
In addition, applications pass control information in a *HAL tag* structure that identifies the session, security policy and date type. HAL uses the tag information to route data to the correct interface and process the data. The *HAL tag* structure has three orthogonal 32-bit unsigned identifiers: *<mux, sec, typ>*, where:
- **mux** is the session multiplexing handle used to identify a unidirectional application flow.
- **sec** identifies the CDG security policy used to processing an ADU. 
- **typ** identifies the type of ADU (based on DFDL xsd definition). The tag *typ* tells HAL how to serialize the ADU. The CDG can also use the tag *typ* (and its associated description) in order to process (e.g., downgrade) the ADU contents based on its rulesets.

In particular, the HAL API provides one send and two receive calls: 
- Asynchronous send, where the message is sent immediately.
- Blocking receive, where the call will block until a message matching the specified tag is received.
- Receive with timeout, where timeout is specified in the xdc_sub_socket_non_blocking() call. 
The associated function calls provided as a library call the the partitioned applications are:

```
void  xdc_asyn_send(void *socket, void *adu, gaps_tag *tag);
int   xdc_recv(void *socket, void *adu, gaps_tag *tag);
void  xdc_blocking_recv(void *socket, void *adu, gaps_tag *tag);
```

Note that, in the above send/receive functions, the *socket* pointer is only used 
by the *HAL-Daemon* implementation, which uses it to identify the 
configured publish and subscribe sockets on the HAL daemon. 
The *socket* pointer is not needed by *HAL-Library* implementation, where its value is ignored.


#### HAL Data Plane Control API {#hal-data-plane-control-api}

Note, however, that the CDG control-planes API for setting up rules for different data types is not currently part of HAL.

Parts of the HAL API are specific to setting up the 0MQ socket interface to the *HAL-Daemon* implementation. However, in order to provide binary compatibility, both HAL implementations support all the same API function calls. The *HAL-library* implementation simply ignores the parts that setup the 0MQ socket, allowing it to run the same compiled code used by the *HAL-Daemon* implementation.


In addition to the send/receive calls, other HAL API calls specify the:
- **Codec function**: The application must register (de-)serialization codec functions for all the datatypes that can be sent over the CDG. Once registered, the correct codec will be selected and invoked when data is sent or received by HAL.
- **Timeout**: used in a non-blocking receive. The application can specify a timeout value (in milliseconds) for each receive tag. If the timeout value is -1, then an xdc_recv() call will block until a message is available; else, for all positive timeout values, an xdc_recv() call will wait for a message for that amount of time before returning with -1 value.
- **Log level**: 0=TRACE, 1=DEBUG, 2=INFO, 3=LOG_WARN, 4=LOG_ERROR, 5=LOG_FATAL. Each log level prints its own level information and all higher levels. Level 2 (the default log level), for example, prints level 2 and higher log information, but no level 1 or level 0 information.


```
void  xdc_register(codec_func_ptr encode, codec_func_ptr decode, int typ);
void *xdc_sub_socket_non_blocking(gaps_tag tag, int timeout);
void  xdc_log_level(int new_level);
```


The HAL Data Plane Control API also defines the inter-process communication identifiers 
used between the Application and the *HAL-Daemon* implementation.
As noted above, these API calls are not used by the *HAL-Library* implementation.


```
extern char *xdc_set_in (char *addr); 
extern char *xdc_set_out(char *addr);
extern void *xdc_ctx(void);
extern void *xdc_pub_socket(void);
extern void *xdc_sub_socket(gaps_tag tag);
```

Currently, the *HAL-Daemon* implements a 0MQ pub/sub pattern, 
with addresses (URIs) associated with the 0MQ publish and subscribe endpoints bound to the HAL daemon. 
The API provides two functions to set these endpoint addresses.

The 0MQ pub/sub sockets must be initialized before sending and receiving cross-domain data. 
The application client API provides the four functions to initialize the sockets. 
- *xdc_ctx()* function creates the 0MQ context (returning a pointer to the context). 
- *xdc_pub_socket()*, *xdc_sub_socket()* and *xdc_sub_socket_non_blocking* (listed earlier). These functions connect to the HAL daemon listening 0MQ sockets, in order to send (on the API pub socket) or receive (on the API sub socket) data. These functions return a (void *) socket pointer. 
With the two sub sockets, the *HAL-Daemon* implementation allows the user specifies 
which HAL packets it wants to receive, using the HAL tag as a filter. 




### HAL Supported CDGs 

HAL communicates with CDGs through host devices. The CDGs may be on the same host as the partitioned application (as a *bookend* (BE) device) or connected via one of the host's network interfaces (as a *bump-in-the-wire* (BW)). 


Examples of host devices include: 
- *Serial devices* carrying TCP/IP packets: e.g., using /dev/dma_proxy_rx and /dev/dma_proxy_rx to communicate with the MIND proxy module.
- *Network devices* in client or server mode: e.g., using the host's eth0 device.
- *Shared-Memory* that has been memory-mapped (mmap'ed): e.g., using /dev/mem.
- *Files* in a Unix directory: e.g., using /tmp/xdc.
For each flow, a HAL configuration file (typically generated by the CLOSURE tool-chain) specifies the specific device along with networking and format requirements.

##### Currently Supported GAPS devices

![Range of Supported GAPS Hardware](docs/C/images/gapshardware.png)

HAL supports the range of GAPS CDG hardware available today. Supported hardware includes: 

- Monitoring & Inspection Device (MIND)
    - Payload parsing/redaction in VHDL
    - Isolated Forward/reverse pipelines
    - Xilinx and GE avionics M256 form-factors

- InLine Interface Processor (ILIP)
    - Xilinx MPSoC bookends
    - Segmentation/Reassembly for large payloads (1 MB+, theoretical 1 GB)
    - Redaction guided by payload offsets

- Extended Secure Capabilities Architecture Platform and Evaluation (ESCAPE)
    - 2-Xeon CPUs connected over UPI to FPGA
    - Address-filtering to allow or disallow read/writes to shared memory pool
    - UPI transfer speeds up to 10.4 GT/s
  
- X-domain Agile Rules-Based Information Transfer OrchestratoR (X-ARBITOR) 
    - Commercial gateway providing simultaneous, bidirectional transfers among different security domains
    - Reading and writing files via X-ARBITOR send and receive proxies.
  
In addition, HAL supports a default pass-through or NULL mode, which requires no GAPS hardware. This is the option currently support on the CLOSURE Emulator (EMU).


All the CDGs listed have been exhaustively tested with HAL. 
However, as shown in the final two columns of the table below, 
each HAL implementation (Daemon and Library) currently support only a subset of the CDGs.


| CDG       | Network     | Message Format | Rx/Tx        | Dae | Lib |
| --------- | ----------- | -------------- | ------------ | --- | --- |
| ESCAPE    | Shared Mem  | CLD SHM pools  | mmap memcpy  | No  | Yes |
| ILIP      | INET        | ILIP packets   | read/write   | Yes | No  |
| MIND      | DMA         | C-Tag packet   | mmap ioctl   | Yes | Yes |      
| X-ARBITOR | Unix Files  | C-Tag packet   | fread/fwrite | No  | Yes |
| NULL      | Serial/INET | C-Tag packet   | read/write   | Yes | No  |


The Message Format column defines one of several supported formats:

- *CLD SHM pools* are per-tag (per unidirectional flow) pools of shared memory (SHM). Each pool contains the flow's Control information (including Tag and buffer read and write indexes) and n buffers containing ADU Length and ADU Data. 
- *ILIP packets* are the four ILIP packet formats supporting immediate and type 1, 2 or 3 payload messages.
- *C-Tag packet* contain the coded data (ADU) plus a header, which has a 32-bit compressed Tag, a 16-bit data length and 16-bit CRC. 
 
 
##### Emulated GAPS devices

To simplify testing of partitioned application, HAL can run partitioned application end-to-end on a single host computer using Emulated GAPS device. These emulated devices use the same network and message format as used with the actual CDG hardware: 

- *ESCAPE Emulation*: Shared Memory (SHM) mapped regions of the host computer act as a stand-in for the shared memory on the ESCAPE FPGA board. This is enabled by editing the SHM header file to define the 'SHM_MMAP_HOST' variable, then recompiling
- *ILIP Emulation*: Use the ILIP loopback driver to emulate the ILIP hardware using Immediate or Payload packets.
- *MIND Emulation*: We use the [pseudo driver](https://github.com/gaps-closure/xdcomms-dma/tree/develop/pseudo) to emulate the MIND proxy DMA driver with the same ioctl commands. After installing the drive, it creates four unix devices: /dev/sue_donimous_rx0, /dev/sue_donimous_rx1, /dev/sue_donimous_tx0, and /dev/sue_donimous_tx1.
- X-ARBITOR Emulation: Files in directories on the host computer act as stand-in for the X-ARBITOR. This can be done by defining the 'FILE_DIR_SHARE' variable, then recompiling. This will put each flow in a separate directory named based on the compressed tag. 
- NULL: This creates a loopback on a single host.  This is implemented using a *socat* or *netcat* to loop the host's serial (e.g., /dev/tty) or INET (e.g., TCP or UDP) connections.

Test examples are given later in this section for emulation of [Shared-Memory](#lib-config-run-emu-shm), 
[MIND](#lib-config-run-emu-mind) and [X-ARBITOR](#lib-config-run-emu-xarb).





### HAL Daemon Implementation

HAL daemon runs as a separate process from the application with the 
API being through a ZeroMQ (0MQ) pub/sub interface. The Application uses the 
 [HAL-API](https://github.com/gaps-closure/hal/blob/develop/api/) *xdcomms C library*,
 in order to connect to the two (a publish and a subscribe) HAL Daemon listening 0MQ sockets.
 The 0MQ sockets can use IPC or INET (e.g., ipc:///tmp/halpub, ipc:///tmp/halsub).

![HAL interfaces between applications and Network Interfaces.](docs/C/images/hal.png)

The HAL daemon service can be started manually or started by a *systemd* script at boot time. The figure shows an example of the HAL daemon supporting multiple applications and CDGs. The figure highlights the three major HAL daemon components:

#### Data Plane Switch
The **Data Plane Switch** forwards packets (containing a tag and ADU) from one interface to another (e.g., from xdd0 to xdd1). Its forwarding in based on the arriving packet's interface name, the packet's [*tag*](#haltag) value, and the HAL configuration file unidirectional mapping rules (**halmap**).  
- When sending data from the applications (on the left side of HAL in the figure above) into the network (on the right side of HAL), HAL [Message Functions](#Message-Functions) will encode (and possibly translate) the **Application tag** into a **Network tag**.
- When receiving data from the network, HAL will decode (and possibly translate) the **Network tag** back into an **Application tag**.

#### Device Manager
The **Device Manager** opens, configures and manages the different types of interfaces (real or emulated) based on the configuration file's device specification (**devices-spec**):
- Opening the devices specified in the configuration file, using each one's specified addressing/port and communication mode. 
- Reading and writing packets. It waits for received packets on all the opened read interfaces (using a select() function) and transmits packets back out onto the halmap-specified write interface.
  
#### Message Functions {#Message-Functions}
The  **Message Functions** transform and control packets exchanged between the applications and guard devices: 
- *Tag translation* between the internal HAL format and the different CDG packet formats. Each CDG packet format has a separate HAL sub-component that performs the tag encoding and decoding: e.g., [packetize_sdh_bw_v1.c](https://github.com/gaps-closure/hal/blob/develop/daemon/packetize_sdh_bw_v1.c) and [packetize_sdh_bw_v1.h](https://github.com/gaps-closure/hal/blob/develop/daemon/packetize_sdh_bw_v1.h).
- *Message mediation* is not currently supported, but may include functions such as multiplexing/demultiplexing, segmentation/reassembly and rate control.


#### HAL Daemon Command Options {#HAL-Daemon-Command-Options}

To see the HAL daemon command options, run with the -h option.  Below shows the current options:

```
~/gaps/hal$ daemon/hal -h
Hardware Abstraction Layer (HAL) for GAPS CLOSURE project (version 0.11)
Usage: hal [OPTIONS]... CONFIG-FILE
OPTIONS: are one of the following:
 -f : log file name (default = no log file)
 -h : print this message
 -l : log level: 0=TRACE, 1=DEBUG, 2=INFO, 3=WARN, 4=ERROR, 5=FATAL (default = 0)
 -q : quiet: disable logging on stderr (default = enabled)
 -w : device not ready (EAGAIN) wait time in microseconds (default = 1000us): -1 exits if not ready
CONFIG-FILE: path to HAL configuration file (e.g., test/sample.cfg)
```

#### HAL Daemon Configuration {#HAL-Configuration}

HAL daemon Configuration uses a a libconfig file specified when starting the HAL daemon
(see the [Quick Start Guide](#quick-start-guide) and the [Install Guide](#halinst)).

The HAL daemon configuration file contains two sections:
- **devices-spec**, which specifies the device configuration for each HAL interface, including:
  - Interface ID (e.g., xdd1), 
  - enable flag,
  - packet format,
  - communication mode,
  - device paths,
  - [optional] addresses and ports,
  - [optional] max packet size (HAL may perform Segment and Reassemble (SAR)),
  - [optional] max rate (bits/second).
- **halmap** routing rules and message functions applied to each allowed unidirectional link.
  - *from_* fields specifying the inbound HAL Interface ID and packet tag values,
  - *to_* fields specifying the outbound HAL Interface ID and packet tag values,
  - message functions specific to this path (e.g., ADU codec).

The [test directory](https://github.com/gaps-closure/hal/tree/develop/test) has examples of configuration files (with a .cfg) extension. Note that, if there are multiple HAL daemon instances on a node (e.g., for testing), then they must be configured with different interfaces.


#### Quick Start Guide {#quick-start-guide}
##### Download Sources, Build, and Install {#download-sources-build-and-install}

We have built and tested HAL on a Linux Ubuntu 20.04 system, and while HAL can run on other operating systems / versions, the package installation instructions are for that particular OS and version.

Install the HAL pre-requisite libraries.
```
sudo apt install -y libzmq3-dev
sudo apt install -y libconfig-dev
```
See the [CLOSURE Dev Server Setup](https://github.com/gaps-closure/build/blob/develop/environment_setup.md) for full listing of CLOSURE external dependencies (some of which may be required for HAL on a newly installed system).

Clone the repository, then run make in order to compile HAL, together with its libraries ([API](https://github.com/gaps-closure/hal/tree/develop/api) and [codecs](https://github.com/gaps-closure/hal/tree/develop/appgen)) and test programs:
```
git clone https://github.com/gaps-closure/hal
cd hal
make clean; make
```
Some SDH devices also require installation of a device driver via an associated kernel module. Consult the GAPS Device provider's documentation.

##### Static Binaries #####

To build a static version of you may need the additional packages for the included minimized static build of 0MQ
```
sudo apt install -y liblzma-dev
sudo apt install -y libunwind-dev
sudo apt install -y libsodium-dev
```

Once you have these dependencies you should simply need to run

```
make clean; make static
```

##### Configure/Run HAL on Target Hardware

An instance of HAL daemon runs on each host or server that directly utilizes the SDH (cross-domain host), and requires a configuration file. If GAPS devices are already configured on enclave hosts in the target environment, we can simply start HAL daemon with the appropriate configuration file in each enclave host:
```
hal$ daemon/hal test/sample_6modemo_b{e|w}_{orange|green}.cfg # e.g. sample_6modemo_be_orange.cfg
```
For this purpose, we have provided sample HAL daemon configuration files that model the Apr '20 demo setup, i.e., green-side and orange-side HAL configurations for either SDH-BE or SDH-BW usage. Note that provided configurations do not mix SDH types for the forward and reverse directions; we will provide these once the hybrid setup becomes available. Also note that contents of the config file may need to be changed depending on the target setup (i.e. SDH-BE device names and SDH-BW end-point IP addresses may differ from those used in current files).

Once the HAL daemon is started, we can run the mission application or a test application such as [halperf](#hal-test-driver-halperfpy) on each enclave.

#### Quick Test of HAL with SDH-BE Loopback or SDH-BW Emulated Network

During development, for testing HAL with SDH-BE loopback drivers or SDH-BW emulated networking, it is possible to run HAL instances for the different enclaves on the same physical machine using their respective configurations. If running this localized setup and if using SDH-BE, the loopback ILIP device driver kernel module `gaps_ilip.ko` must be built and installed using `insmod` before starting HAL. 

```
# Obtain and untar driver source package from SDh-BE developer
cd loopback/ilip
# If using v0.2.0, edit line 426 in ilip_nl.c from #if 0  to  #if 1
vi ilip_nl.c
make clean; make install
insmod gaps_ilip.ko
```

If using SDH-BW, an emulated network (e.g., `test/6MoDemo_BW.net.sh` as shown below) must be configured before starting HAL to instantiate virtual ethernet devices and netcat processes to facilitate the packet movement. The `halperf` test application can then be invoked to send and receive the application traffic workload.

Steps for an end-to-end test for Apr '20 Demo testing on a single host are provided below.

1. Open five terminals (terminal1, terminal2, ... terminal5).
2. Assuming SDH-BW for this example; start the emulated network in terminal3 (skip for SDH-BE):
```
terminal3:
  hal$ cd tests
  hal/tests$: sudo ./6MoDemo_BW.net.sh
```
3. Start HAL (this example assumes SDH-BW) for green and orange enclaves
```
terminal1 (green):
  hal$ daemon/hal test/sample_6modemo_bw_green.cfg

terminal2 (orange):
  hal$ daemon/hal test/sample_6modemo_bw_orange.cfg
```
4. An instance of halperf.py can both send and receive messages. Run an instance on both green and orange enclaves and send the appropriate mux/sec/typ combinations that correspond to the HAL tag specification for the Mission App datatypes:
```
terminal4 (green):
  export LD_LIBRARY_PATH=../appgen/6month-demo
  hal/test$ ./halperf.py -s 1 1 1 100 -r 2 2 1 -r 2 2 2 -i ipc:///tmp/halsubbwgreen -o ipc:///tmp/halpubbwgreen

terminal5 (orange):
  export LD_LIBRARY_PATH=../appgen/6month-demo
  hal/test$ ./halperf.py -s 2 2 1 10 -s 2 2 2 100 -r 1 1 1 -i ipc:///tmp/halsubbworange -o ipc:///tmp/halpubbworange
  ```
Note the -i and -o arguments which correspond to input/output ZMQ interfaces utilized by HAL. The example provided is for SDH-BW. If using SDH-BE, replace 'bw' with 'be' for each -i and -o argument (e.g. halpub<b>bw</b>orange --> halpub<b>be</b>orange)

The sending rates in the above calls are 1 Hz for simplicity. (For the representative mission application rates, you can send 1,1,1 at 100Hz, 2,2,1 at 10Hz, and 2,2,2 at 100Hz instead. Other rates and application mixes can be used for stress-testing or for testing policy rules.) Example output:
```
terminal4 (green):
sent: [1/1/1] -- (-74.574489,40.695545,102.100000)
recv: [2/2/2] -- (-1.021000,2.334000,0.900000)
recv: [2/2/1] -- (-74.574489,40.695545,102.400000)

terminal5 (orange):
recv: [1/1/1] -- (-74.574489,40.695545,102.100000)
sent: [2/2/2] -- (-1.021000,2.334000,0.900000)
sent: [2/2/1] -- (-74.574489,40.695545,102.400000)
```

##### Cleanup of HAL Components
Ctrl-C can be used to kill most processes. Additional cleanup scripts are provided if needed:
```
hal/test$ ./kill_my_hall.sh f
hal/test$ sudo pkill -f "nc -klu"
hal/test$ sudo pkill -f "nc -u"
```

#### HAL Daemon Installation and Usage {#halinst}

##### Build HAL

See [Download Sources, Build, and Install](#download-sources-build-and-install) for required steps.

##### Run HAL
Starting the HAL daemon requires specifying a HAL configuration file and any [options](#HAL-Daemon-Command-Options). The [test directory](https://github.com/gaps-closure/hal/tree/develop/test) has examples of configuration files (with a .cfg) extension. 

###### HAL Loopback Mode
At its simplest, we can start HAL to echo send requests made back on the application interface. Loopback mode is enabled by specifying the loopback configuration file [test/config_simple_exampes/sample_loopback.cfg](https://github.com/gaps-closure/hal/blob/develop/test/config_simple_examples/sample_loopback.cfg)

```
cd hal
hal$ daemon/hal test/config_simple_examples/sample_loopback.cfg
```
In this case, HAL receives packets on its application read interface and routes them back to its application write interface. This requires no network devices (or network access).

Below is an example of the logging output from the HAL daemon, showing its configuration:
- Single device called *xdd0*, using a pub/sub ipc connection (using connection mode sdh_ha_v1), with file descriptors 3 and 6 for reading and writing.
- A single HAL map (*halmap*) routing entry, which forwards application data from the application *xdd0* device with a HAL tag *<mux, sec, typ> = <1,1,1>* back to the application *xdd0* device. It also translates that tag to *<mux, sec, typ> = <1,2309737967,1>*
```
hal$ daemon/hal test/sample_loopback.cfg 
HAL device list:
 xdd0 [v=1 d=./zc/zc m=sdh_ha_v1 c=ipc mi=sub mo=pub fr=3 fw=6]
HAL map list (0x5597a6af8150):
 xdd0 [mux=01 sec=01 typ=01] ->  xdd0 [mux=01 sec=2309737967 typ=01] , codec=NULL

HAL Waiting for input on fds, 3
```
###### HAL Test Driver (halperf.py) {#hal-test-driver-halperfpy}
We provide an easy to use utility, <b>halperf.py</b>, for sending and receiving Mission App datatypes (Position/Distance) while utilizing HAL and SDH. halperf constructs an in-memory instance of the datatype, provides it to HAL with appropriate application [tag](#haltag), HAL maps it to the configured SDH, constructs the on-wire format, and releases a frame to the SDH. The receive-side HAL unrolls the frame and provides it to the receiving halperf instance.
```
usage: halperf.py [-h] [-s MUX SEC TYP RATE] [-r MUX SEC TYP] [-l PATH]
                  [-x PATH] [-i URI] [-o URI]

optional arguments:
  -h, --help            show this help message and exit
  -s MUX SEC TYP RATE, --send MUX SEC TYP RATE
                        send cross-domain flow using MUX/SEC/TYP at RATE (Hz)
  -r MUX SEC TYP, --recv MUX SEC TYP
                        recv cross-domain flow mapped to MUX/SEC/TYP
  -l PATH               path to mission app shared libraries
                        (default=../appgen/6month-demo)
  -x PATH               path to libxdcomms.so (default=../api)
  -i URI                in URI (default=ipc:///tmp/halpub1)
  -o URI                out URI (default=ipc:///tmp/halsub1)

```

The [HAL daemon configuration](#halconfig) uses a libconfig File, which contains HAL maps (routes) and Device configurations. 





### HAL Library Implementation {#hal-library-implementation}

The application links with the [HAL xdcomms-dma C library](https://github.com/gaps-closure/xdcomms-dma/blob/develop/).
to call the xdcomms API function. 

#### HAL-Library Configuration

*HAL-Library* uses three types of configuration information, from:
- **JSON configuration file**. The file defines the one-way channel definitions, specifying channel tags and enclave end-point names.
- UNIX environment variables. Selection of device configuration is done through UNIX environment variables specified when running the partitioned application. 
- **Device header files**. For each types of supported CDG, 

A simple example of a *HAL-Library* JSON configuration file is the one used by the test application:
[xdconf_app_req_rep.json](https://github.com/gaps-closure/xdcomms-dma/tree/develop/test_app/xdconf_app_req_rep.json).
It supports two types of client requests/responses (using position or raw data) 
JSON configuration files are auto-generated by the CLOSURE tools. 
An auto-configured example with 10 different unidirectional tags, used in the [websrv](https://github.com/gaps-closure/eop2-closure-mind-demo) demo, is
[xdconf.ini](https://github.com/gaps-closure/eop2-closure-mind-demo/blob/main/websrv/.solution/partitioned/multithreaded/xdconf.ini).

The table below list the current list of environment variables when using the HAL Library Implementation. 

| ENVIR. VARIABLE  | Description                    |
| ---------------  | -----------------------------  |
| CONFIG_FILE      | JSON configuration file        | 
| DEV_NAME_RX      | Name of receive device         |  
| DEV_NAME_TX      | Name of transmit device        |
| DEV_TYPE_RX      | Receiver Device type           | 
| DEV_TYPE_TX      | Transmitter Device type        | 
| ENCLAVE          | Enclave Name (in CONFIG_FILE)  | 
| LD_LIBRARY_PATH  | Path to xdcomms library        | 
| SHM_WAIT4NEW     | Wait for new client if not 0   | 
| XARB_IP          | X-ARBITOR Proxy IP address     | 
| XARB_PORT        | X-ARBITOR Proxy TCP PORT       |
| XDCLOGLEVEL      | Debug log level                |

The [HAL XDCOMMS General Control APIs](#hal-general-api) section describes the various log levels
The default values, which in some cases depend on the DEV_TYPE are given below. 
If the variable is not used with a DEV_TYPE, then it is marked as -).

| ENVIR. VARIABLE  | default value in {dma, file, shm}       |      
| ---------------  | --------------------------------------  |
| CONFIG_FILE      | REQUIRED (no default)                   |
| DEV_NAME_RX    | {/dev/dma_proxy_rx, /tmp/xdc, /dev/mem} |  
| DEV_NAME_TX    | {/dev/dma_proxy_tx, /tmp/xdc, /dev/mem} |
| DEV_TYPE_RX      | dma                                     |
| DEV_TYPE_TX      | dma                                     |
| ENCLAVE          | REQUIRED (no default)                   |
| LD_LIBRARY_PATH  | Linux OS path                           |
| SHM_WAIT4NEW     | { -, -, 0 }                             |
| XARB_IP          | { -, 192.168.100.101, - }               |
| XARB_PORT        | { -, 1124, - }                          |
| XDCLOGLEVEL      | Value in xdc_log_level() call; else 2   |

The partitioned application may have its own environmental variables. For example, the  [websrv](https://github.com/gaps-closure/eop2-closure-mind-demo) demo uses environmental variables to define the IP addresses:

| ENVIR. VARIABLE  | Description      | default value      |      
| ---------------  | ---------------  | --------------------  |
| CAMADDR          | Camera IP address | REQUIRED (no default) |
| MYADDR           | APPs IP address   | REQUIRED (no default) |


XDCOMMS-lib has a header file that defines the communication device configuration:
    - **DMA**: [dma-proxy.h](https://github.com/gaps-closure/xdcomms-dma/tree/develop/api/dma-proxy.h). 
    - **SHM**: [shm.h](https://github.com/gaps-closure/xdcomms-dma/tree/develop/api/shm.h). 
    - **FILE**: [file_info.h](https://github.com/gaps-closure/xdcomms-dma/tree/develop/api/file_info.h). 



#### HAL Library Quick Start Guide {#lib-quick-start-guide}

To install and build the *HAL-Library*, together with the test application and pseudo driver, run the following commands:
```
  cd ~/gaps
  git clone git@github.com:gaps-closure/xdcomms-dma
  cd xdcomms-dma/
  make clean
  make 
```

Once the xdcomms library is installed and built, we can install the pseudo DMA driver module 
into the kernel, if required, in order to emulate the MIND DMA [CDG](#cdg-interfaces). 
The following are the commands to install the modules and re-compile the HAL xdcomms library: 

```
  cd ~/gaps/xdcomms-dma/pseudo
  ./reset_sue_dominous.sh
  lsmod | grep sue; ls -l /dev/sue*
```

 After installing the driver (see below), it should list four unix devices: 
 - /dev/sue_donimous_rx0,
 - /dev/sue_donimous_rx1, 
 - /dev/sue_donimous_tx0,
 - /dev/sue_donimous_tx1.
 
All the examples below use the test application, which is included in the xdcomms-dma in the 
[test_app](https://github.com/gaps-closure/xdcomms-dma/tree/develop/test_app) directory. 
In particular, they use it to generate a single request-response handshake from the green
enclave client to the orange enclave server, where:
- Green sends a client_request_position message (tag <1,1,1>), which causes
- Orange to reply with a server_response_position message (tag <2,2,1>).


##### Configure/Run Test Application on Emulated MIND CDG Hardware {#lib-config-run-emu-mind}

Ensure the pseudo DMA driver module is loaded, then recompile XDCOMMS-lib based on the pseudo-driver parameters:

```
  cd ~/gaps/xdcomms-dma/api
  make clean
  make -f Makefile.pseudo 
```

Run the test application in two terminal windows. In the first start the app for the orange enclave as a server:

```
  cd ~/gaps/xdcomms-dma/test_app
  ENCLAVE=orange CONFIG_FILE=xdconf_app_req_rep.json DEV_NAME_RX=sue_donimous_rx1 \
  DEV_NAME_TX=sue_donimous_tx1 LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  XDCLOGLEVEL=1 ./app_req_rep -e 2
```

In the second window start the app for the green enclave as a client:

```
  cd ~/gaps/xdcomms-dma/test_app
  ENCLAVE=green CONFIG_FILE=xdconf_app_req_rep.json DEV_NAME_RX=sue_donimous_rx0 \
  DEV_NAME_TX=sue_donimous_tx0 LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  XDCLOGLEVEL=1 ./app_req_rep
```

##### Configure/Run Test Application on Emulated SHM CDG Hardware {#lib-config-run-emu-shm}

Recompile XDCOMMS-lib to use use the host Shared Memory by defining the SHM_MMAP_HOST variable in shm.h:
```
  cd ~/gaps/xdcomms-dma/api
  sed -i 's@^//#define\ SHM_MMAP_HOST@#define\ SHM_MMAP_HOST@g' shm.h
  make clean
  make  
```

Run the test application in two terminal windows. In the first start the app for the orange enclave as a server:

```
  cd ~/gaps/xdcomms-dma/test_app
  sudo ENCLAVE=orange CONFIG_FILE=xdconf_app_req_rep.json DEV_TYPE_RX=shm \
  DEV_TYPE_TX=shm SHM_WAIT4NEW=1 LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  XDCLOGLEVEL=1 ./app_req_rep -e 2
```

In the second window start the app for the green enclave as a client:

```
  cd ~/gaps/xdcomms-dma/test_app
  sudo ENCLAVE=green CONFIG_FILE=xdconf_app_req_rep.json DEV_TYPE_RX=shm \
  DEV_TYPE_TX=shm LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  XDCLOGLEVEL=1 ./app_req_rep
```

##### Configure/Run Test Application on Emulated X-ARBIOR Hardware {#lib-config-run-emu-xarb}

Recompile XDCOMMS-lib to use use the put each flow in a separate directory by defining the FILE_DIR_SHARE varaible in file_info.h to equal 0:

```
  cd ~/gaps/xdcomms-dma/api
  sed -i 's@1 // Flows share@0 // Flows share@g' tt
  make clean
  make  
```

Run the test application in two terminal windows. In the first start the app for the orange enclave as a server:

```
  cd ~/gaps/xdcomms-dma/test_app
  ENCLAVE=orange CONFIG_FILE=xdconf_app_req_rep.json DEV_TYPE_RX=file \
  DEV_TYPE_TX=file LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  DEV_NAME_RX=/tmp/xdc/2 DEV_NAME_TX=/tmp/xdc/1 XARB_IP=1.2.3.4 \
  XDCLOGLEVEL=1 ./app_req_rep -e 2
```

In the second window start the app for the green enclave as a client:

```
  cd ~/gaps/xdcomms-dma/test_app
  ENCLAVE=green CONFIG_FILE=xdconf_app_req_rep.json DEV_TYPE_RX=file \
  DEV_TYPE_TX=file LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  DEV_NAME_TX=/tmp/xdc/2 DEV_NAME_RX=/tmp/xdc/1 XARB_IP=1.2.3.5 \
  XDCLOGLEVEL=1 ./app_req_rep
```


##### Configure/Run Test Application on MIND CDG Hardware {#lib-config-run-mind}

VNC into a demo laptop with the XILINX DMA BOARD (e.g., 10.109.23.205:1). 
Instruction for loading the PetaLinux images and starting the a53 and Mcroblaze processors can be 
found in the 
[End of Phase 2 demo repository](https://github.com/gaps-closure/eop2-closure-mind-demo/blob/main/). 
Specifcally, the [setup](https://github.com/gaps-closure/eop2-closure-mind-demo/blob/main/demo_notes_1_setup.txt)
and [run](https://github.com/gaps-closure/eop2-closure-mind-demo/blob/main/demo_notes_2_run_apps.txt)
notes.
Note that:
- The a53 and mb PetaLinux images are put the compiled test code and its json configuration file
into the /opt/closure/test_app directory. 
- The dma modules should be reset (using modprobe) for each run
- The green enclave should be started first followed within 3 seconds by the orange enclave.
- These notes also give instructions for running the compiled eop2 websrv application in 
the /opt/closure/websrv directory.

Run the test application in a53 and mb minicom terminal windows. 
In the first window start the app for the green enclave as a client 
(with the -l option specifying the log level as 1 (debug), 
which is equivalent to specifying the environmental variable XDCLOGLEVEL=1):

```
  cd /opt/closure/test_app
  modprobe -r dma_proxy && modprobe dma_proxy 
  ENCLAVE=green CONFIG_FILE=xdconf_app_req_rep.json ./app_req_rep -l 1
```

In the second window start the app for the orange enclave as a server:

```
  cd /opt/closure/test_app
  modprobe -r dma_proxy && modprobe dma_proxy 
  ENCLAVE=orange CONFIG_FILE=xdconf_app_req_rep.json ./app_req_rep -e 2 -l 1
```

##### Configure/Run Test Application on ESCAPE FPGA CDG Hardware {#lib-config-run-escape}

VNC or SSH into two ESCAPE servers: escape-orange (e.g., 10.109.23.130) and escape-green (e.g., 10.109.23.131).
First enable the ESCAPE Ruleset (pass-through mode) for the shared memory.

```
  sudo escape_app -w 0x810 0x00000000 0x82000000
  sudo escape_app -w 0x818 0x00000000 0x8200ffff
  sudo escape_app -w 0x800 0x00000000 0x00000001 
```

Then test the shared memory using the ESCAPE *memtest* code. 
On green terminal write some data into the start of the FPGA shared memory:

```
  sudo memtest 0x2080000000 8 w w 0x123456789abcdef
```

In the orange terminal read the start of the FPGA shared memory:

```    
  sudo memtest 0x2080000000 32 w r
```
      
Load and Compile XDCOMMS-lib into each enclave

```
  cd ~/gaps
  git clone git@github.com:gaps-closure/xdcomms-dma
  cd xdcomms-dma/
  make clean
  make 
```

On the first server start the app for the orange enclave as a server:

```
  cd ~/gaps/xdcomms-dma/test_app
  sudo ENCLAVE=orange CONFIG_FILE=xdconf_app_req_rep.json DEV_TYPE_RX=shm \
  DEV_TYPE_TX=shm SHM_WAIT4NEW=1 LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  XDCLOGLEVEL=1 ./app_req_rep -e 2
```

In the second window start the app for the green enclave as a client:

```
  cd ~/gaps/xdcomms-dma/test_app
  sudo ENCLAVE=green CONFIG_FILE=xdconf_app_req_rep.json DEV_TYPE_RX=shm \
  DEV_TYPE_TX=shm LD_LIBRARY_PATH=~/gaps/xdcomms-dma/api \
  XDCLOGLEVEL=1 ./app_req_rep
```
